<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building a Configuration File Parser with C++ | Vision Tech Insights</title>
<meta name=keywords content="hardware programming,C++"><meta name=description content="A comprehensive guide on how to build a configuration file parser with C++ from scratch."><meta name=author content="Jian Zhong"><link rel=canonical href=http://localhost:1313/posts/building_a_configuration_file_parser_with_cpp/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5ff2630c4d1b3e25bc21f0ecd96681dbcf58219e741fa627857820b5485cb770.css integrity="sha256-X/JjDE0bPiW8IfDs2WaB289YIZ50H6YnhXggtUhct3A=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/building_a_configuration_file_parser_with_cpp/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Building a Configuration File Parser with C++"><meta property="og:description" content="A comprehensive guide on how to build a configuration file parser with C++ from scratch."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/building_a_configuration_file_parser_with_cpp/"><meta property="og:image" content="http://localhost:1313/images/building_a_configuration_file_parser_with_cpp/CppConfigFileModuleStructure.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-21T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-21T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/images/building_a_configuration_file_parser_with_cpp/CppConfigFileModuleStructure.png"><meta name=twitter:title content="Building a Configuration File Parser with C++"><meta name=twitter:description content="A comprehensive guide on how to build a configuration file parser with C++ from scratch."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Building a Configuration File Parser with C++","item":"http://localhost:1313/posts/building_a_configuration_file_parser_with_cpp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building a Configuration File Parser with C++","name":"Building a Configuration File Parser with C\u002b\u002b","description":"A comprehensive guide on how to build a configuration file parser with C++ from scratch.","keywords":["hardware programming","C++"],"articleBody":"Configuration files are commonly used to adjust settings in computer programs. I’m presently developing a configuration file parser for my high-speed data acquisition system using C++. Along the way, I’ve discovered some useful techniques involving C++ generics and inheritance that streamline coding. Therefore, I decided to document these tricks in the hope that they’ll be beneficial to others. You can find the ready-to-use source code for this configuration file module in this GitHub repository. (URL: https://github.com/JianZhongDev/CppConfigFile.)\nConfiguration Files According to Wikipedia, configuration files are files used to set up the parameters and initial settings for computer programs. A configuration file parser is a piece of program that allows saving program settings to and loading them from configuration files. Configuration files are very handy when users need to provide certain configuration settings to the program before starting it. In my research, I’ve also discovered the convenience of having a configuration file parser to record the configuration settings of my experiments. This enables me to quickly switch between different software settings for various applications.\nRequirement Analysis For a data acquisition program, users often need to fine-tune settings to optimize performance for their specific needs. This includes things like timing delays, filtering coefficients, and switching between different data processing methods. These settings are stored as variables with various data types (like numbers, strings, and arrays) in the software. So, the configuration file parser has to handle a wide range of data types.\nWe also want the configuration file to be easily readable and editable by users, so it needs to be in a human-readable text format. This means the parser should be able to convert variables to strings and back again.\nPlus, it’d be great if users could add comments to the configuration file to keep track of changes.\nIn summary, here’s what the configuration file parser needs to do:\nStore multiple setting variables and their values. Handle values with different data types. Convert variables to strings, and update values from strings. Save settings to a text file that’s easy for humans to read. Update variable values from the text file. Process configuration files with comments. Data Structure and Algorithm Design Once we’ve nailed down the requirements, we can begin designing the data structures to meet them.\nGeneric Entry To handle the task of storing variables with different data types (requirement 2), we can develop our own custom class called GenericEntry. This class will enable us to access the data within it using the set() and get() methods for writing and reading data, respectively. Since different data types require different methods for reading and writing, we make these set() and get() methods virtual and require subclasses to implement them. The GenericEntry class also includes a type_name member and a get_typename() method to record the data type and verify data types.\nFor converting data to and from strings (requirement 3), considering that various data types require different approaches for this conversion, the GenericEntry class provides write_val_string() and read_val_string() methods. These methods facilitate converting the data value to a string and vice versa.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // Base type of generic entry class GenericEntry { protected: std::string type_name; public: //TODO: could potentially change the return type from void to int and return error flag //TODO: could potentially use type_index instead of hardcoded string as the type identifier GenericEntry() { // set up the type_name in the constructor this-\u003etype_name = \"generic_entry\"; } // Set value of the entry virtual void set() { //Override this method in subclass } // Get value of the entry virtual void get() { //Override this method in subclass } // Return string of the type name void get_typename(std::string* dst_string) { *dst_string = this-\u003etype_name; } // Write the value of the entry into string virtual void write_val_string(std::string* dst_string) { //Override this method in subclass } // Read value of the entry from string virtual void read_val_string(const std::string\u0026 src_string) { //Override this method in subclass } }; Once we’ve set up the most basic entry type, we create a more specialized subclass named TypedEntry. Leveraging the generics template feature, we implement the set() and get() functions. However, because custom classes, iterable types, and primitive data types (like int and unsigned int) require unique approaches for converting their data to strings, we leave the write_val_string()and read_val_string() methods for future implementation in more specialized subclasses.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // Entry of generic type definition template\u003ctypename data_t\u003e class TypedEntry : public GenericEntry { protected: data_t data; public: //Constructor without initial value TypedEntry() { this-\u003etype_name = \"typed_entry\"; } //Constructor with initial value TypedEntry(data_t data) { this-\u003eTypedEntry(); this-\u003edata = data_t(data); } // Implemented set entry value method template\u003ctypename data_t\u003e void set(const data_t\u0026 data) { this-\u003edata = data_t(data); } // Implemented get entry value method template\u003ctypename data_t\u003e void get(data_t* data_p) { *data_p = data_t(this-\u003edata); } virtual void write_val_string(std::string* dst_string) { //Override this method in subclass } virtual void read_val_string(const std::string\u0026 src_string) { //Override this method in subclass } }; Primitive types (like int and unsigned int) have straightforward methods for converting between data and strings. We can implement their entry classes like this: For each specific primitive type, we simply inherit from the primitive type entry and specify the type name in the constructors.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Entries with primitive type template\u003ctypename data_t\u003e class PrimitiveTypeEntry : public TypedEntry\u003cdata_t\u003e { // NOTE: Only need to define contructor giving type_name in the subclasses public: PrimitiveTypeEntry() { this-\u003etype_name = \"primitivetype_entry\"; } PrimitiveTypeEntry(const data_t\u0026 data) { this-\u003ePrimitiveTypeEntry(); this-\u003edata = data_t(data); } virtual void write_val_string(std::string* dst_string) { *dst_string = std::to_string(this-\u003edata); } virtual void read_val_string(const std::string\u0026 src_string) { if (std::is_fundamental\u003cdata_t\u003e::value) { // validate the data type is primitive data type std::stringstream(src_string) \u003e\u003e this-\u003edata; // use stringstream to convert value string to value } } }; // Entries with int type class IntEntry : public PrimitiveTypeEntry\u003cint\u003e { public: IntEntry(int data = 0) { this-\u003etype_name = \"int\"; this-\u003edata = data; } }; We can apply a similar approach to define types for vectors as well.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // Vector class with primitive data type template\u003ctypename data_t\u003e class VectorPrimitiveTypeEntry : public TypedEntry\u003cstd::vector\u003cdata_t\u003e\u003e { // NOTE: Only need to define contructor giving type_name in the subclasses protected: //NOTE: data string format: {val0, val1, val2} std::string str_dl = \",\"; std::string str_enclosure[2] = { \"{\", \"}\" }; public: VectorPrimitiveTypeEntry() { this-\u003etype_name = \"vector_primitivetype\"; } VectorPrimitiveTypeEntry(const std::vector\u003cdata_t\u003e\u0026 data) { this-\u003eVectorPrimitiveTypeEntry(); this-\u003edata = std::vector\u003cdata_t\u003e(data); } virtual void write_val_string(std::string* dst_string) { std::stringstream result_strstream; unsigned data_len = this-\u003edata.size(); unsigned count = 0; // iterate through data vector result_strstream \u003c\u003c this-\u003estr_enclosure[0]; for (auto itr = this-\u003edata.begin(); itr != this-\u003edata.end(); ++itr) { result_strstream \u003c\u003c std::to_string(*itr); count++; if (count \u003c data_len) result_strstream \u003c\u003c this-\u003estr_dl; } result_strstream \u003c\u003c this-\u003estr_enclosure[1]; *dst_string = result_strstream.str(); } virtual void read_val_string(const std::string\u0026 src_string) { // remove '{', '}', and '_' std::string tmp_str = helper_extract_string_between_enclosure(src_string, str_enclosure[0], str_enclosure[1]); tmp_str = helper_clean_tailheadchars_string(tmp_str, std::unordered_set\u003cchar\u003e{' '}); // extract value string for each element std::vector\u003cstd::string\u003e val_strs = helper_split_string_with_delimiter(tmp_str, this-\u003estr_dl); if (std::is_fundamental\u003cdata_t\u003e::value) { // validate data type // iterate through value strings for each element this-\u003edata.clear(); for (auto itr = val_strs.begin(); itr != val_strs.end(); ++itr) { data_t tmp_val; std::stringstream(*itr) \u003e\u003e tmp_val; this-\u003edata.push_back(tmp_val); } } } }; // Entry with float vector class VectorFloatEntry : public VectorPrimitiveTypeEntry\u003cfloat\u003e { public: VectorFloatEntry(const std::vector\u003cfloat\u003e\u0026 data = { 0.0 }) { this-\u003etype_name = \"vector_float\"; this-\u003edata = std::vector\u003cfloat\u003e(data); } }; Since a string is a more specialized class-based data type, we need to define its entry separately.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Entries with string type class StringEntry : public TypedEntry\u003cstd::string\u003e { protected: // NOTE: value string format: \"value_string\" std::string str_enclosure[2] = { \"\\\"\", \"\\\"\" }; public: StringEntry(const std::string\u0026 data = \"\") { this-\u003etype_name = \"string\"; this-\u003edata = data; } virtual void write_val_string(std::string* dst_string) { // Add \" \" to string *dst_string = str_enclosure[0] + std::string(this-\u003edata) + str_enclosure[1]; } virtual void read_val_string(const std::string\u0026 src_string) { // Extract string between \" \" std::string tmp_str = helper_extract_string_between_enclosure(src_string, str_enclosure[0], str_enclosure[1]); this-\u003edata = std::string(tmp_str); } }; Generic Hashmap Once we’ve got our generic entry class ready, we can tackle the task of storing data for multiple settings variables (requirement 1). We can achieve this by using a hash map (std::unordered_map), where we map the name of each setting variable to the entry storing its value. One important thing to remember is that when defining the hashmap, the value should be declared as a pointer to the base class. This prevents any issues where a subclass might get casted into the base class when adding it to the hashmap.\n1 2 typedef std::unordered_map\u003cstd::string, GenericEntry*\u003e GenHashMap; GenHashMap test_genhashmap; With this generic hashmap setup, adding setting variables and entries is straightforward:\n1 2 // initialize generic hash map test_genhashmap[\"int_val\"] = new IntEntry(1); Converting the entry to and from a string is as simple as this:\n1 2 3 4 5 // update entry with string test_map[\"int_val\"]-\u003eread_val_string(\"-1\"); // convert entry value into string std::string tmp_valstr; test_map[\"int_val\"]-\u003ewrite_val_string(\u0026tmp_valstr); After casting the entry to its subclass, we can easily set and retrieve values within the entry.\n1 2 3 4 5 // set value of entry ((IntEntry*)test_genhashmap[\"int_val\"])-\u003eset(-1); // get value from entry int tmp_int; ((IntEntry*)test_genhashmap[\"int_val\"])-\u003eget(\u0026tmp_int); Furthermore, we can easily determine the type of the entry by calling the get_typename() method.\n1 2 3 // get type name string from entry std::string tmp_typename; test_map[\"int_val\"]-\u003eget_typename(\u0026tmp_typename); To simplify clearing the entire hashmap, I’ve created the clear_genhashmap() function, outlined below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 typedef int errflag_t; // delete all the elements in a generic hash map errflag_t clear_genhashmap( std::unordered_map\u003cstd::string, GenericEntry*\u003e\u0026 gen_hashmap ) { // iterate through the hash map to release all the entries for (auto key_val_pair : gen_hashmap) { delete key_val_pair.second; } gen_hashmap.clear(); return 1; } Note: If maintaining the order of setting variables in the configuration file is crucial for your application, you can easily achieve this by switching the data type from std::unordered_map (hashmap) to std::ordered_map (tree-based map). Everything else in the code remains unchanged and can be used as is.\nSaving Configuration Files Since we’ve already implemented the string conversion function in the entries, saving the setting parameters to human-readable text files is straightforward. We simply need to iterate through the generic hashmap, saving the name (key), type, and value of each entry. Then, we add entry separators at the end of each entry and dump them into a text file. Additionally, I’ve included a header string to provide some helpful information in the configuration file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // pack type name value string into one string std::string helper_pack_type_name_val_string( const std::string\u0026 type_string, const std::string\u0026 name_string, const std::string\u0026 val_string, const std::string\u0026 type_name_dl = \" \", const std::string\u0026 name_val_dl = \"=\" ) { return type_string + type_name_dl + name_string + name_val_dl + val_string; } typedef int errflag_t; // save generic hash map entries to configuration text file errflag_t save_genhashmap_to_txt( const std::unordered_map\u003cstd::string, GenericEntry*\u003e\u0026 gen_hashmap, const std::string\u0026 dst_file_path, std::ios_base::openmode dst_file_openmode = std::ios_base::out, const std::string\u0026 type_name_dl = \" \", const std::string\u0026 name_val_dl = \"=\", const std::string\u0026 entry_stop_str = \";\", const std::vector\u003cstd::string\u003e\u0026 default_message_enclousre = {\"/*\", \"*/\"}, const std::string\u0026 head_message = \"\" ) { errflag_t err_flag = 0; std::ofstream dst_file(dst_file_path, dst_file_openmode); if (dst_file.is_open()) { // save head message if given if (head_message.size() \u003e 0) { dst_file \u003c\u003c default_message_enclousre[0] + head_message + default_message_enclousre[1] + \"\\n\"; } // iterate though hash map and save all entries for (const auto\u0026 key_val_pair : gen_hashmap) { std::string cur_name_str = key_val_pair.first; std::string cur_type_str; std::string cur_val_str; key_val_pair.second-\u003eget_typename(\u0026cur_type_str); key_val_pair.second-\u003ewrite_val_string(\u0026cur_val_str); // convert type name value to entry string std::string cur_entry_str = helper_pack_type_name_val_string( cur_type_str, cur_name_str, cur_val_str, type_name_dl, name_val_dl ); dst_file \u003c\u003c cur_entry_str + entry_stop_str + \"\\n\"; } dst_file.close(); // close file err_flag = 1; } else { std::cout \u003c\u003c \"ERR:\\t Unable to open file. File path = \" + dst_file_path \u003c\u003c std::endl; err_flag = -1; } return err_flag; } Loading Configuration Files Reading the setting information from the configuration file involves a bit more complexity. We need to handle comments in the file and avoid mistakenly reading separators within strings of entries with string type. These requirements are addressed by iterating through the entire configuration file string using two pointers. Here’s how it works:\nThe faster pointer moves ahead to mark the end of each candidate string while continuously checking the substring. The slower pointer sets the start position of each candidate string. Depending on the substring, the algorithm behaves as follows: If the substring matches the start separator of a string candidate to ignore, the faster pointer moves forward while ignoring all substrings until it finds the end separator of the ignore string candidate. If the substring matches the start separator of a comment string, the faster pointer continues moving forward while ignoring until it finds the end separator of the comment string candidate. The slower pointer ends up positioned after the end of the comment candidate string so that it’s not read in. If the substring matches the end separator of an entry string candidate, the substring between the slow and fast pointers is saved into the result vector. This indicates that we’ve found the string for the setting parameter entry. The entry string candidate undergoes some cleaning processes to remove any extra spaces and newline characters at both ends. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // extract entry strings from complicated strings std::vector\u003cstd::string\u003e helper_extract_entrystr( const std::string\u0026 src_string, const std::string\u0026 entry_stop_str = \";\", //string indicates the end of an entry string std::unordered_map\u003cstd::string, std::string\u003e ignore_left_to_right_map = { {\"//\", \"\\n\"}, {\"/*\", \"*/\"} }, //string parts between \"left\" and \"right\" to ignore std::unordered_map\u003cstd::string, std::string\u003e include_left_to_right_map = { {\"\\\"\", \"\\\"\"} } //string parts between \"left\" and \"right\" to include ) { std::size_t slow_idx = 0; std::size_t fast_idx = 0; std::size_t srcstr_len = src_string.size(); std::size_t entry_stop_str_len = entry_stop_str.size(); // count string lengths in the left_to_right map keys std::unordered_set\u003cstd::size_t\u003e ignore_left_lens; for (const auto\u0026 itr : ignore_left_to_right_map) { ignore_left_lens.insert(itr.first.size()); } // count string lengths in the left_to_right map keys std::unordered_set\u003cstd::size_t\u003e include_left_lens; for (const auto\u0026 itr : include_left_to_right_map) { include_left_lens.insert(itr.first.size()); } // itrate through src_string to find all entry strings std::vector\u003cstd::string\u003e entry_strs; while (fast_idx \u003c srcstr_len) { // check string between \"left\" and \"right\" to include for (auto cur_left_len : include_left_lens) { if (fast_idx + cur_left_len \u003e srcstr_len) continue; std::string cur_left_str = src_string.substr(fast_idx, cur_left_len); if (include_left_to_right_map.find(cur_left_str) != include_left_to_right_map.end()) { std::string cur_right_str = include_left_to_right_map[cur_left_str]; std::size_t cur_right_len = cur_right_str.size(); for (fast_idx += cur_left_len; fast_idx + cur_right_len \u003c srcstr_len; ++fast_idx) { if (src_string.substr(fast_idx, cur_right_len) == cur_right_str) break; } fast_idx += cur_right_len; } } // check string between \"left\" and \"right\" to exclude for (auto cur_left_len : ignore_left_lens) { if (fast_idx + cur_left_len \u003e srcstr_len) continue; std::string cur_left_str = src_string.substr(fast_idx, cur_left_len); if (ignore_left_to_right_map.find(cur_left_str) != ignore_left_to_right_map.end()) { std::string cur_right_str = ignore_left_to_right_map[cur_left_str]; std::size_t cur_right_len = cur_right_str.size(); for (fast_idx += cur_left_len; fast_idx + cur_right_len \u003c srcstr_len; ++fast_idx) { if (src_string.substr(fast_idx, cur_right_len) == cur_right_str) break; } fast_idx += cur_right_len; slow_idx = fast_idx; } } if (fast_idx + entry_stop_str_len \u003e srcstr_len) break; // reach the end of src_string // found complete entry string if (src_string.substr(fast_idx, entry_stop_str_len) == entry_stop_str) { entry_strs.push_back(src_string.substr(slow_idx, fast_idx - slow_idx)); slow_idx = fast_idx + 1; } ++fast_idx; } return entry_strs; } Once we have the entry strings, we’ll break them down into type, name, and value fields. Each string for these fields will be cleaned up, removing any extra spaces and newline characters at both ends. Then, we’ll check if the hashmap has a key with the specified name, using it to identify the entries. We’ll then examine the value of the entry and update it with the corresponding value string if the type matches.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 typedef int errflag_t; // update generic hash map entries according to configuration text file errflag_t update_genhashmap_from_txt( std::unordered_map\u003cstd::string, GenericEntry*\u003e\u0026 gen_hashmap, const std::string\u0026 src_file_path, std::ios_base::openmode src_file_openmode = std::ios_base::in, const std::string\u0026 type_name_dl = \" \", const std::string\u0026 name_val_dl = \"=\", const std::string\u0026 entry_stop_str = \";\", const std::unordered_map\u003cstd::string, std::string\u003e\u0026 ignore_left_to_right_map = {{\"//\", \"\\n\"}, {\"/*\", \"*/\"}}, const std::unordered_map\u003cstd::string, std::string\u003e\u0026 include_left_to_right_map = {{\"\\\"\", \"\\\"\"}}, const std::unordered_set\u003cchar\u003e\u0026 rm_chars = {' ', '\\n', '\\t'} ) { errflag_t err_flag = 0; std::ifstream src_file(src_file_path, src_file_openmode); if (src_file.is_open()) { std::string src_string( (std::istreambuf_iterator\u003cchar\u003e(src_file)), std::istreambuf_iterator\u003cchar\u003e() ); std::vector\u003cstd::string\u003e entry_strings = helper_extract_entrystr( src_string, entry_stop_str, ignore_left_to_right_map, include_left_to_right_map ); for (auto\u0026 cur_entry_str : entry_strings) { std::string tmp_str; std::size_t tmp_str_len = 0; //clean up entry string tmp_str = helper_bothside_clean_chars( cur_entry_str, rm_chars ); // split entry string std::string type_string; std::string name_string; std::string value_string; helper_split_entrystr_into_type_name_val( tmp_str, type_name_dl, name_val_dl, \u0026type_string, \u0026name_string, \u0026value_string ); // clean up name string name_string = helper_bothside_clean_chars( name_string, rm_chars ); // update entry if name exists if (gen_hashmap.find(name_string) != gen_hashmap.end()) { type_string = helper_bothside_clean_chars( type_string, rm_chars ); // update entry if type match std::string hp_typename; gen_hashmap[name_string]-\u003eget_typename(\u0026hp_typename); if (type_string == hp_typename) { value_string = helper_bothside_clean_chars( value_string, rm_chars ); gen_hashmap[name_string]-\u003eread_val_string(value_string); } else { std::cout \u003c\u003c \"ERR:\\tType mismatch! \" + type_string + \" \u003c--\u003e \" + hp_typename + \"\\n\"; } } else { std::cout \u003c\u003c \"ERR:\\tName not found! \" + name_string + \"\\n\"; } } err_flag = 1; } else { std::cout \u003c\u003c \"ERR:\\t Unable to open file. File path = \" + src_file_path \u003c\u003c std::endl; err_flag = -1; } return err_flag; } Since we typically use the same separators and comment notations when writing and reading the configuration file, it makes sense to create a class to store these separators and comment notations for the functions responsible for saving and loading the configuration file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 typedef int errflag_t; // class for text IO of generic hash map class GenHashMapIOTxt { public: std::string type_name_dl = \" \"; std::string name_val_dl = \"=\"; std::string entry_stop_str = \";\"; std::vector\u003cstd::string\u003e default_message_enclousre = { \"/*\", \"*/\" }; std::unordered_map\u003cstd::string, std::string\u003e ignore_left_to_right_map = { {\"//\", \"\\n\"}, {\"/*\", \"*/\"} }; std::unordered_map\u003cstd::string, std::string\u003e include_left_to_right_map = { {\"\\\"\", \"\\\"\"} }; std::unordered_set\u003cchar\u003e rm_chars = { ' ', '\\n', '\\t' }; // save generic hash map to file errflag_t save_to_file( const std::unordered_map\u003cstd::string, GenericEntry*\u003e\u0026 gen_hashmap, const std::string\u0026 dst_file_path, std::ios_base::openmode dst_file_openmode = std::ios_base::out, const std::string\u0026 head_message = \"\" ) { return save_genhashmap_to_txt( gen_hashmap, dst_file_path, dst_file_openmode, this-\u003etype_name_dl, //this-\u003ename_val_dl, \" \" + this-\u003ename_val_dl + \" \", this-\u003eentry_stop_str, this-\u003edefault_message_enclousre, head_message ); } // load generic hash map errflag_t update_from_file( std::unordered_map\u003cstd::string, GenericEntry*\u003e\u0026 gen_hashmap, const std::string\u0026 src_file_path, std::ios_base::openmode src_file_openmode = std::ios_base::in ) { return update_genhashmap_from_txt( gen_hashmap, src_file_path, src_file_openmode, this-\u003etype_name_dl, this-\u003ename_val_dl, this-\u003eentry_stop_str, this-\u003eignore_left_to_right_map, this-\u003einclude_left_to_right_map, this-\u003erm_chars ); } }; Unit Test Finally, we can quickly test the configuration file parser. In the following code, I’ve used an integer entry, a vector of floats entry, and a string entry as examples.\nFirst, we create the generic hashmap and add initial entries to it. Then, we save the generic hashmap to a text file. Next, we modify the values in the generic map. Finally, we load the values from the configuration file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 void main() { GenHashMap test_genhashmap; GenHashMapIOTxt test_io_txt; // initialize generic hash map test_genhashmap[\"int_val\"] = new IntEntry(1); test_genhashmap[\"string_val\"] = new StringEntry(\"Welcome to Vision Tech Insights!\"); test_genhashmap[\"vector_float_val\"] = new VectorFloatEntry({ 0.1, 0.2, 0.3, 0.4, 0.5 }); std::cout \u003c\u003c \"====== Initialize gen hashmap ======\" \u003c\u003c std::endl \u003c\u003c std::endl; // print all the values in the generic hash map std::cout \u003c\u003c \"--- genhashmap values START ---\" \u003c\u003c std::endl; for (const auto\u0026 key_val_pair : test_genhashmap) { std::string cur_name_str = key_val_pair.first; std::string cur_type_str; std::string cur_val_str; key_val_pair.second-\u003eget_typename(\u0026cur_type_str); key_val_pair.second-\u003ewrite_val_string(\u0026cur_val_str); std::cout \u003c\u003c cur_type_str \u003c\u003c \" \" \u003c\u003c cur_name_str \u003c\u003c \" = \" \u003c\u003c cur_val_str \u003c\u003c std::endl; } std::cout \u003c\u003c \"--- genhashmap values END ---\" \u003c\u003c std::endl; std::cout \u003c\u003c std::endl; // save generic hash map into a text file std::cout \u003c\u003c \"====== Save gen hashmap to text file ======\" \u003c\u003c std::endl \u003c\u003c std::endl; // save to txt configuration file test_io_txt.save_to_file( test_genhashmap, \"test_config_file.txt\", std::ios_base::out, \"This is the test configuration file for Vision Tech Insights blog.\" ); // save generic hash map into a text file std::cout \u003c\u003c \"====== Set values in gen hashmap ======\" \u003c\u003c std::endl \u003c\u003c std::endl; // try to change some of the values ((IntEntry*)test_genhashmap[\"int_val\"])-\u003eset(-1); ((StringEntry*)test_genhashmap[\"string_val\"])-\u003eset(std::string(\"Hello world!\")); ((VectorFloatEntry*)test_genhashmap[\"vector_float_val\"])-\u003eset(std::vector\u003cfloat\u003e{-0.1, -0.2, -0.3}); std::cout \u003c\u003c \"--- genhashmap values START ---\" \u003c\u003c std::endl; for (const auto\u0026 key_val_pair : test_genhashmap) { std::string cur_name_str = key_val_pair.first; std::string cur_type_str; std::string cur_val_str; key_val_pair.second-\u003eget_typename(\u0026cur_type_str); key_val_pair.second-\u003ewrite_val_string(\u0026cur_val_str); std::cout \u003c\u003c cur_type_str \u003c\u003c \" \" \u003c\u003c cur_name_str \u003c\u003c \" = \" \u003c\u003c cur_val_str \u003c\u003c std::endl; } std::cout \u003c\u003c \"--- genhashmap values END ---\" \u003c\u003c std::endl; std::cout \u003c\u003c std::endl; // try to get value from genhashmap std::cout \u003c\u003c \"====== Get values from gen hashmap ======\" \u003c\u003c std::endl \u003c\u003c std::endl; int tmp_int; ((IntEntry*)test_genhashmap[\"int_val\"])-\u003eget(\u0026tmp_int); std::string tmp_string; ((StringEntry*)test_genhashmap[\"string_val\"])-\u003eget(\u0026tmp_string); std::vector\u003cfloat\u003e tmp_float_vec; ((VectorFloatEntry*)test_genhashmap[\"vector_float_val\"])-\u003eget(\u0026tmp_float_vec); std::cout \u003c\u003c \"--- get values START ---\" \u003c\u003c std::endl; std::cout \u003c\u003c \"tmp_int = \" \u003c\u003c tmp_int \u003c\u003c std::endl; std::cout \u003c\u003c \"tmp_float_vec = {\"; for (int i_val = 0; i_val \u003c tmp_float_vec.size(); i_val++) { std::cout \u003c\u003c tmp_float_vec[i_val]; if (i_val \u003c tmp_float_vec.size() - 1) { std::cout \u003c\u003c \", \"; } } std::cout \u003c\u003c \"}\" \u003c\u003c std::endl; std::cout \u003c\u003c \"tmp_string = \" \u003c\u003c tmp_string \u003c\u003c std::endl; std::cout \u003c\u003c \"--- get values END ---\" \u003c\u003c std::endl; std::cout \u003c\u003c std::endl; // load generic hash map from the text file std::cout \u003c\u003c \"====== Load gen hashmap from text file ======\" \u003c\u003c std::endl \u003c\u003c std::endl; // update values according to txt configuration file test_io_txt.update_from_file( test_genhashmap, \"test_config_file.txt\", std::ios_base::in ); std::cout \u003c\u003c \"--- genhashmap values START ---\" \u003c\u003c std::endl; for (const auto\u0026 key_val_pair : test_genhashmap) { std::string cur_name_str = key_val_pair.first; std::string cur_type_str; std::string cur_val_str; key_val_pair.second-\u003eget_typename(\u0026cur_type_str); key_val_pair.second-\u003ewrite_val_string(\u0026cur_val_str); std::cout \u003c\u003c cur_type_str \u003c\u003c \" \" \u003c\u003c cur_name_str \u003c\u003c \" = \" \u003c\u003c cur_val_str \u003c\u003c std::endl; } std::cout \u003c\u003c \"--- genhashmap values END ---\" \u003c\u003c std::endl; std::cout \u003c\u003c std::endl; // release generic entries and clear gen hashmap clear_genhashmap(test_genhashmap); } The resulting configuration file (“test_config_file.txt”) looks like this:\n/*This is the test configuration file for Vision Tech Insights blog.*/ int int_val = 1; string string_val = \"Welcome to Vision Tech Insights!\"; vector_float vector_float_val = {0.100000,0.200000,0.300000,0.400000,0.500000}; The output of the execution is as follows:\n====== Initialize gen hashmap ====== --- genhashmap values START --- int int_val = 1 string string_val = \"Welcome to Vision Tech Insights!\" vector_float vector_float_val = {0.100000,0.200000,0.300000,0.400000,0.500000} --- genhashmap values END --- ====== Save gen hashmap to text file ====== ====== Set values in gen hashmap ====== --- genhashmap values START --- int int_val = -1 string string_val = \"Hello world!\" vector_float vector_float_val = {-0.100000,-0.200000,-0.300000} --- genhashmap values END --- ====== Get values from gen hashmap ====== --- get values START --- tmp_int = -1 tmp_float_vec = {-0.1, -0.2, -0.3} tmp_string = Hello world! --- get values END --- ====== Load gen hashmap from text file ====== --- genhashmap values START --- int int_val = 1 string string_val = \"Welcome to Vision Tech Insights!\" vector_float vector_float_val = {0.100000,0.200000,0.300000,0.400000,0.500000} --- genhashmap values END --- Conclusion This post offers an example implementation of a configuration file parser using C++. We’ve developed a generic entry class to handle various data types and convert them into strings. Leveraging inheritance and generics in C++ allows us to reuse code blocks for different data types. Storing entries and their corresponding variable names in a hashmap enables us to manage multiple variables simultaneously. With a classic two-pointer-based string processing algorithm, we can save the hashmap to or load it from the configuration file.\nCitation If you found this article helpful, please cite it as:\nZhong, Jian (Apr 2024). Building a Configuration File Parser with C++. Vision Tech Insights. https://jianzhongdev.github.io/VisionTechInsights/posts/building_a_configuration_file_parser_with_cpp/.\nOr\n@article{zhong2024configfileparsercpp, title = \"Building a Configuration File Parser with C++\", author = \"Zhong, Jian\", journal = \"jianzhongdev.github.io\", year = \"2024\", month = \"Apr\", url = \"https://jianzhongdev.github.io/VisionTechInsights/posts/building_a_configuration_file_parser_with_cpp/.\" } References [1] “Configuration file.” Wikipedia, The Free Encyclopedia. Wikimedia Foundation, Inc. Retrieved April 21, 2024, from https://en.wikipedia.org/wiki/Configuration_file.\n","wordCount":"4359","inLanguage":"en","image":"http://localhost:1313/images/building_a_configuration_file_parser_with_cpp/CppConfigFileModuleStructure.png","datePublished":"2024-04-21T00:00:00Z","dateModified":"2024-04-21T00:00:00Z","author":{"@type":"Person","name":"Jian Zhong"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/building_a_configuration_file_parser_with_cpp/"},"publisher":{"@type":"Organization","name":"Vision Tech Insights","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Vision Tech Insights (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Vision Tech Insights</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Building a Configuration File Parser with C++</h1><div class=post-description>A comprehensive guide on how to build a configuration file parser with C++ from scratch.</div><div class=post-meta><span title='2024-04-21 00:00:00 +0000 UTC'>April 21, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;4359 words&nbsp;·&nbsp;Jian Zhong</div></header><figure class=entry-cover><img loading=eager srcset="http://localhost:1313/images/building_a_configuration_file_parser_with_cpp/CppConfigFileModuleStructure_hu8d53bdb34eb1f9b827302effc8fef181_670772_360x0_resize_box_3.png 360w ,http://localhost:1313/images/building_a_configuration_file_parser_with_cpp/CppConfigFileModuleStructure_hu8d53bdb34eb1f9b827302effc8fef181_670772_480x0_resize_box_3.png 480w ,http://localhost:1313/images/building_a_configuration_file_parser_with_cpp/CppConfigFileModuleStructure_hu8d53bdb34eb1f9b827302effc8fef181_670772_720x0_resize_box_3.png 720w ,http://localhost:1313/images/building_a_configuration_file_parser_with_cpp/CppConfigFileModuleStructure_hu8d53bdb34eb1f9b827302effc8fef181_670772_1080x0_resize_box_3.png 1080w ,http://localhost:1313/images/building_a_configuration_file_parser_with_cpp/CppConfigFileModuleStructure_hu8d53bdb34eb1f9b827302effc8fef181_670772_1500x0_resize_box_3.png 1500w ,http://localhost:1313/images/building_a_configuration_file_parser_with_cpp/CppConfigFileModuleStructure.png 3510w" sizes="(min-width: 768px) 720px, 100vw" src=http://localhost:1313/images/building_a_configuration_file_parser_with_cpp/CppConfigFileModuleStructure.png alt="[cover image] diagram of the configuration file parser (image credit: Jian Zhong)" width=3510 height=2478><p>[cover image] diagram of the configuration file parser (image credit: Jian Zhong)</p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#configuration-files>Configuration Files</a></li><li><a href=#requirement-analysis>Requirement Analysis</a></li><li><a href=#data-structure-and-algorithm-design>Data Structure and Algorithm Design</a><ul><li><a href=#generic-entry>Generic Entry</a></li><li><a href=#generic-hashmap>Generic Hashmap</a></li><li><a href=#saving-configuration-files>Saving Configuration Files</a></li><li><a href=#loading-configuration-files>Loading Configuration Files</a></li></ul></li><li><a href=#unit-test>Unit Test</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#citation>Citation</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>Configuration files are commonly used to adjust settings in computer programs. I&rsquo;m presently developing a configuration file parser for my high-speed data acquisition system using C++. Along the way, I&rsquo;ve discovered some useful techniques involving C++ generics and inheritance that streamline coding. Therefore, I decided to document these tricks in the hope that they&rsquo;ll be beneficial to others. You can find the ready-to-use source code for this configuration file module in this <a href=https://github.com/JianZhongDev/CppConfigFile>GitHub repository</a>. (URL: <a href=https://github.com/JianZhongDev/CppConfigFile>https://github.com/JianZhongDev/CppConfigFile</a>.)</p><h2 id=configuration-files>Configuration Files<a hidden class=anchor aria-hidden=true href=#configuration-files>#</a></h2><p>According to <a href=https://en.wikipedia.org/wiki/Configuration_file>Wikipedia</a>, configuration files are files used to set up the parameters and initial settings for computer programs. A configuration file parser is a piece of program that allows saving program settings to and loading them from configuration files. Configuration files are very handy when users need to provide certain configuration settings to the program before starting it. In my research, I&rsquo;ve also discovered the convenience of having a configuration file parser to record the configuration settings of my experiments. This enables me to quickly switch between different software settings for various applications.</p><h2 id=requirement-analysis>Requirement Analysis<a hidden class=anchor aria-hidden=true href=#requirement-analysis>#</a></h2><p>For a data acquisition program, users often need to fine-tune settings to optimize performance for their specific needs. This includes things like timing delays, filtering coefficients, and switching between different data processing methods. These settings are stored as variables with various data types (like numbers, strings, and arrays) in the software. So, the configuration file parser has to handle a wide range of data types.</p><p>We also want the configuration file to be easily readable and editable by users, so it needs to be in a human-readable text format. This means the parser should be able to convert variables to strings and back again.</p><p>Plus, it&rsquo;d be great if users could add comments to the configuration file to keep track of changes.</p><p>In summary, here&rsquo;s what the configuration file parser needs to do:</p><ol><li>Store multiple setting variables and their values.</li><li>Handle values with different data types.</li><li>Convert variables to strings, and update values from strings.</li><li>Save settings to a text file that&rsquo;s easy for humans to read.</li><li>Update variable values from the text file.</li><li>Process configuration files with comments.</li></ol><h2 id=data-structure-and-algorithm-design>Data Structure and Algorithm Design<a hidden class=anchor aria-hidden=true href=#data-structure-and-algorithm-design>#</a></h2><p>Once we&rsquo;ve nailed down the requirements, we can begin designing the data structures to meet them.</p><h3 id=generic-entry>Generic Entry<a hidden class=anchor aria-hidden=true href=#generic-entry>#</a></h3><p>To handle the task of storing variables with different data types (requirement 2), we can develop our own custom class called <code>GenericEntry</code>. This class will enable us to access the data within it using the <code>set()</code> and <code>get()</code> methods for writing and reading data, respectively. Since different data types require different methods for reading and writing, we make these <code>set()</code> and <code>get()</code> methods virtual and require subclasses to implement them. The <code>GenericEntry</code> class also includes a <code>type_name</code> member and a <code>get_typename()</code> method to record the data type and verify data types.</p><p>For converting data to and from strings (requirement 3), considering that various data types require different approaches for this conversion, the <code>GenericEntry</code> class provides <code>write_val_string()</code> and <code>read_val_string()</code> methods. These methods facilitate converting the data value to a string and vice versa.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// Base type of generic entry
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>GenericEntry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>type_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>//TODO: could potentially change the return type from void to int and return error flag
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//TODO: could potentially use type_index instead of hardcoded string as the type identifier
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>GenericEntry</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// set up the type_name in the constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>type_name</span> <span class=o>=</span> <span class=s>&#34;generic_entry&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Set value of the entry
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>set</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>//Override this method in subclass 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Get value of the entry
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>get</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>//Override this method in subclass 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Return string of the type name
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span> <span class=nf>get_typename</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>dst_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=n>dst_string</span> <span class=o>=</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>type_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Write the value of the entry into string
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>write_val_string</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>dst_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>//Override this method in subclass 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Read value of the entry from string
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>read_val_string</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>src_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>//Override this method in subclass 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Once we&rsquo;ve set up the most basic entry type, we create a more specialized subclass named <code>TypedEntry</code>. Leveraging the generics template feature, we implement the <code>set()</code> and <code>get()</code> functions. However, because custom classes, iterable types, and primitive data types (like <code>int</code> and <code>unsigned int</code>) require unique approaches for converting their data to strings, we leave the <code>write_val_string()</code>and <code>read_val_string()</code> methods for future implementation in more specialized subclasses.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// Entry of generic type definition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>data_t</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TypedEntry</span> <span class=o>:</span> <span class=k>public</span> <span class=n>GenericEntry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>data_t</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>//Constructor without initial value
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>TypedEntry</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>type_name</span> <span class=o>=</span> <span class=s>&#34;typed_entry&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>//Constructor with initial value
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>TypedEntry</span><span class=p>(</span><span class=n>data_t</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>TypedEntry</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>data_t</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Implemented set entry value method
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>data_t</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>set</span><span class=p>(</span><span class=k>const</span> <span class=n>data_t</span><span class=o>&amp;</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>data_t</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Implemented get entry value method
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>data_t</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>get</span><span class=p>(</span><span class=n>data_t</span><span class=o>*</span> <span class=n>data_p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=n>data_p</span> <span class=o>=</span> <span class=n>data_t</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>write_val_string</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>dst_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>//Override this method in subclass 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>read_val_string</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>src_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>//Override this method in subclass
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Primitive types (like <code>int</code> and <code>unsigned int</code>) have straightforward methods for converting between data and strings. We can implement their entry classes like this: For each specific primitive type, we simply inherit from the primitive type entry and specify the type name in the constructors.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// Entries with primitive type  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>data_t</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PrimitiveTypeEntry</span> <span class=o>:</span> <span class=k>public</span> <span class=n>TypedEntry</span><span class=o>&lt;</span><span class=n>data_t</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// NOTE: Only need to define contructor giving type_name in the subclasses
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>PrimitiveTypeEntry</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>type_name</span> <span class=o>=</span> <span class=s>&#34;primitivetype_entry&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>PrimitiveTypeEntry</span><span class=p>(</span><span class=k>const</span> <span class=n>data_t</span><span class=o>&amp;</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>PrimitiveTypeEntry</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>data_t</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>write_val_string</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>dst_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=n>dst_string</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>to_string</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>read_val_string</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>src_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_fundamental</span><span class=o>&lt;</span><span class=n>data_t</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// validate the data type is primitive data type
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>std</span><span class=o>::</span><span class=n>stringstream</span><span class=p>(</span><span class=n>src_string</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span> <span class=c1>// use stringstream to convert value string to value
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Entries with int type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>IntEntry</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PrimitiveTypeEntry</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>IntEntry</span><span class=p>(</span><span class=kt>int</span> <span class=n>data</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>type_name</span> <span class=o>=</span> <span class=s>&#34;int&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>We can apply a similar approach to define types for vectors as well.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// Vector class with primitive data type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>data_t</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>VectorPrimitiveTypeEntry</span> <span class=o>:</span> <span class=k>public</span> <span class=n>TypedEntry</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>data_t</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// NOTE: Only need to define contructor giving type_name in the subclasses
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>//NOTE: data string format: {val0, val1, val2}
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>str_dl</span> <span class=o>=</span> <span class=s>&#34;,&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>str_enclosure</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=s>&#34;{&#34;</span><span class=p>,</span> <span class=s>&#34;}&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>VectorPrimitiveTypeEntry</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>type_name</span> <span class=o>=</span> <span class=s>&#34;vector_primitivetype&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>VectorPrimitiveTypeEntry</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>data_t</span><span class=o>&gt;&amp;</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>VectorPrimitiveTypeEntry</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>data_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>write_val_string</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>dst_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>stringstream</span> <span class=n>result_strstream</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kt>unsigned</span> <span class=n>data_len</span> <span class=o>=</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=kt>unsigned</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// iterate through data vector
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>result_strstream</span> <span class=o>&lt;&lt;</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>str_enclosure</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>itr</span> <span class=o>=</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>itr</span> <span class=o>!=</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>itr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>result_strstream</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>to_string</span><span class=p>(</span><span class=o>*</span><span class=n>itr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>&lt;</span> <span class=n>data_len</span><span class=p>)</span> <span class=n>result_strstream</span> <span class=o>&lt;&lt;</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>str_dl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=n>result_strstream</span> <span class=o>&lt;&lt;</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>str_enclosure</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=n>dst_string</span> <span class=o>=</span> <span class=n>result_strstream</span><span class=p>.</span><span class=n>str</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>read_val_string</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>src_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// remove &#39;{&#39;, &#39;}&#39;, and &#39;_&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tmp_str</span> <span class=o>=</span> <span class=n>helper_extract_string_between_enclosure</span><span class=p>(</span><span class=n>src_string</span><span class=p>,</span> <span class=n>str_enclosure</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>str_enclosure</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>		<span class=n>tmp_str</span> <span class=o>=</span> <span class=n>helper_clean_tailheadchars_string</span><span class=p>(</span><span class=n>tmp_str</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>{</span><span class=sc>&#39; &#39;</span><span class=p>});</span>
</span></span><span class=line><span class=cl>		<span class=c1>// extract value string for each element
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>val_strs</span> <span class=o>=</span> <span class=n>helper_split_string_with_delimiter</span><span class=p>(</span><span class=n>tmp_str</span><span class=p>,</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>str_dl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_fundamental</span><span class=o>&lt;</span><span class=n>data_t</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// validate data type
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// iterate through value strings for each element
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>itr</span> <span class=o>=</span> <span class=n>val_strs</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>itr</span> <span class=o>!=</span> <span class=n>val_strs</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>itr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>data_t</span> <span class=n>tmp_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=n>std</span><span class=o>::</span><span class=n>stringstream</span><span class=p>(</span><span class=o>*</span><span class=n>itr</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>tmp_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>tmp_val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Entry with float vector
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>VectorFloatEntry</span> <span class=o>:</span> <span class=k>public</span> <span class=n>VectorPrimitiveTypeEntry</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>VectorFloatEntry</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;&amp;</span> <span class=n>data</span> <span class=o>=</span> <span class=p>{</span> <span class=mf>0.0</span> <span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>type_name</span> <span class=o>=</span> <span class=s>&#34;vector_float&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Since a string is a more specialized class-based data type, we need to define its entry separately.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// Entries with string type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>StringEntry</span> <span class=o>:</span> <span class=k>public</span> <span class=n>TypedEntry</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>// NOTE: value string format: &#34;value_string&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>str_enclosure</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>StringEntry</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>data</span> <span class=o>=</span> <span class=s>&#34;&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>type_name</span> <span class=o>=</span> <span class=s>&#34;string&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>write_val_string</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>dst_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Add &#34; &#34; to string
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=o>*</span><span class=n>dst_string</span> <span class=o>=</span> <span class=n>str_enclosure</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span> <span class=o>+</span> <span class=n>str_enclosure</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>read_val_string</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>src_string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Extract string between &#34; &#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tmp_str</span> <span class=o>=</span> <span class=n>helper_extract_string_between_enclosure</span><span class=p>(</span><span class=n>src_string</span><span class=p>,</span> <span class=n>str_enclosure</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>str_enclosure</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=n>tmp_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=generic-hashmap>Generic Hashmap<a hidden class=anchor aria-hidden=true href=#generic-hashmap>#</a></h3><p>Once we&rsquo;ve got our generic entry class ready, we can tackle the task of storing data for multiple settings variables (requirement 1). We can achieve this by using a hash map (<code>std::unordered_map</code>), where we map the name of each setting variable to the entry storing its value. One important thing to remember is that when defining the hashmap, the value should be declared as a pointer to the base class. This prevents any issues where a subclass might get casted into the base class when adding it to the hashmap.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>GenericEntry</span><span class=o>*&gt;</span> <span class=n>GenHashMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>GenHashMap</span> <span class=n>test_genhashmap</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>With this generic hashmap setup, adding setting variables and entries is straightforward:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// initialize generic hash map
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;int_val&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>IntEntry</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>Converting the entry to and from a string is as simple as this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// update entry with string
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>test_map</span><span class=p>[</span><span class=s>&#34;int_val&#34;</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>read_val_string</span><span class=p>(</span><span class=s>&#34;-1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// convert entry value into string
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tmp_valstr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>test_map</span><span class=p>[</span><span class=s>&#34;int_val&#34;</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>write_val_string</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp_valstr</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>After casting the entry to its subclass, we can easily set and retrieve values within the entry.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// set value of entry
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>((</span><span class=n>IntEntry</span><span class=o>*</span><span class=p>)</span><span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;int_val&#34;</span><span class=p>])</span><span class=o>-&gt;</span><span class=n>set</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// get value from entry
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>tmp_int</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>((</span><span class=n>IntEntry</span><span class=o>*</span><span class=p>)</span><span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;int_val&#34;</span><span class=p>])</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp_int</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>Furthermore, we can easily determine the type of the entry by calling the get_typename() method.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// get type name string from entry
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tmp_typename</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>test_map</span><span class=p>[</span><span class=s>&#34;int_val&#34;</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>get_typename</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp_typename</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>To simplify clearing the entire hashmap, I&rsquo;ve created the clear_genhashmap() function, outlined below:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>errflag_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// delete all the elements in a generic hash map
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>errflag_t</span> <span class=nf>clear_genhashmap</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>GenericEntry</span><span class=o>*&gt;&amp;</span> <span class=n>gen_hashmap</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// iterate through the hash map to release all the entries
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>key_val_pair</span> <span class=p>:</span> <span class=n>gen_hashmap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>delete</span> <span class=n>key_val_pair</span><span class=p>.</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>gen_hashmap</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Note: If maintaining the order of setting variables in the configuration file is crucial for your application, you can easily achieve this by switching the data type from <code>std::unordered_map</code> (hashmap) to <code>std::ordered_map</code> (tree-based map). Everything else in the code remains unchanged and can be used as is.</p><h3 id=saving-configuration-files>Saving Configuration Files<a hidden class=anchor aria-hidden=true href=#saving-configuration-files>#</a></h3><p>Since we&rsquo;ve already implemented the string conversion function in the entries, saving the setting parameters to human-readable text files is straightforward. We simply need to iterate through the generic hashmap, saving the name (key), type, and value of each entry. Then, we add entry separators at the end of each entry and dump them into a text file. Additionally, I&rsquo;ve included a header string to provide some helpful information in the configuration file.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// pack type name value string into one string
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>helper_pack_type_name_val_string</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>type_string</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name_string</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>val_string</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>type_name_dl</span> <span class=o>=</span> <span class=s>&#34; &#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name_val_dl</span> <span class=o>=</span> <span class=s>&#34;=&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>type_string</span> <span class=o>+</span> <span class=n>type_name_dl</span> <span class=o>+</span> <span class=n>name_string</span> <span class=o>+</span> <span class=n>name_val_dl</span> <span class=o>+</span> <span class=n>val_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>errflag_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// save generic hash map entries to configuration text file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>errflag_t</span> <span class=n>save_genhashmap_to_txt</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>GenericEntry</span><span class=o>*&gt;&amp;</span> <span class=n>gen_hashmap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>dst_file_path</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>openmode</span> <span class=n>dst_file_openmode</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>out</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>type_name_dl</span> <span class=o>=</span> <span class=s>&#34; &#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name_val_dl</span> <span class=o>=</span> <span class=s>&#34;=&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>entry_stop_str</span> <span class=o>=</span> <span class=s>&#34;;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&amp;</span> <span class=n>default_message_enclousre</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;/*&#34;</span><span class=p>,</span> <span class=s>&#34;*/&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>head_message</span> <span class=o>=</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>errflag_t</span> <span class=n>err_flag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>ofstream</span> <span class=n>dst_file</span><span class=p>(</span><span class=n>dst_file_path</span><span class=p>,</span> <span class=n>dst_file_openmode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>dst_file</span><span class=p>.</span><span class=n>is_open</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// save head message if given
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>head_message</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>dst_file</span> <span class=o>&lt;&lt;</span> <span class=n>default_message_enclousre</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>head_message</span> <span class=o>+</span> <span class=n>default_message_enclousre</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// iterate though hash map and save all entries
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>key_val_pair</span> <span class=p>:</span> <span class=n>gen_hashmap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_name_str</span> <span class=o>=</span> <span class=n>key_val_pair</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_type_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_val_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>key_val_pair</span><span class=p>.</span><span class=n>second</span><span class=o>-&gt;</span><span class=n>get_typename</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cur_type_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>key_val_pair</span><span class=p>.</span><span class=n>second</span><span class=o>-&gt;</span><span class=n>write_val_string</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cur_val_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=c1>// convert type name value to entry string
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_entry_str</span> <span class=o>=</span> <span class=n>helper_pack_type_name_val_string</span><span class=p>(</span>
</span></span><span class=line><span class=cl>				<span class=n>cur_type_str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=n>cur_name_str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=n>cur_val_str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=n>type_name_dl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=n>name_val_dl</span>
</span></span><span class=line><span class=cl>			<span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>dst_file</span> <span class=o>&lt;&lt;</span> <span class=n>cur_entry_str</span> <span class=o>+</span> <span class=n>entry_stop_str</span> <span class=o>+</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=n>dst_file</span><span class=p>.</span><span class=n>close</span><span class=p>();</span> <span class=c1>// close file
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>err_flag</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;ERR:</span><span class=se>\t</span><span class=s> Unable to open file. File path = &#34;</span> <span class=o>+</span> <span class=n>dst_file_path</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>err_flag</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>err_flag</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=loading-configuration-files>Loading Configuration Files<a hidden class=anchor aria-hidden=true href=#loading-configuration-files>#</a></h3><p>Reading the setting information from the configuration file involves a bit more complexity. We need to handle comments in the file and avoid mistakenly reading separators within strings of entries with string type. These requirements are addressed by iterating through the entire configuration file string using two pointers.
Here&rsquo;s how it works:</p><ul><li>The faster pointer moves ahead to mark the end of each candidate string while continuously checking the substring.</li><li>The slower pointer sets the start position of each candidate string.</li><li>Depending on the substring, the algorithm behaves as follows:<ul><li>If the substring matches the start separator of a string candidate to ignore, the faster pointer moves forward while ignoring all substrings until it finds the end separator of the ignore string candidate.</li><li>If the substring matches the start separator of a comment string, the faster pointer continues moving forward while ignoring until it finds the end separator of the comment string candidate. The slower pointer ends up positioned after the end of the comment candidate string so that it&rsquo;s not read in.</li><li>If the substring matches the end separator of an entry string candidate, the substring between the slow and fast pointers is saved into the result vector. This indicates that we&rsquo;ve found the string for the setting parameter entry. The entry string candidate undergoes some cleaning processes to remove any extra spaces and newline characters at both ends.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// extract entry strings from complicated strings
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>helper_extract_entrystr</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>src_string</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>entry_stop_str</span> <span class=o>=</span> <span class=s>&#34;;&#34;</span><span class=p>,</span> <span class=c1>//string indicates the end of an entry string
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>ignore_left_to_right_map</span> <span class=o>=</span> <span class=p>{</span> <span class=p>{</span><span class=s>&#34;//&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>},</span> <span class=p>{</span><span class=s>&#34;/*&#34;</span><span class=p>,</span> <span class=s>&#34;*/&#34;</span><span class=p>}</span> <span class=p>},</span> <span class=c1>//string parts between &#34;left&#34; and &#34;right&#34; to ignore
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>include_left_to_right_map</span> <span class=o>=</span> <span class=p>{</span> <span class=p>{</span><span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>}</span> <span class=p>}</span> <span class=c1>//string parts between &#34;left&#34; and &#34;right&#34; to include
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>slow_idx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>fast_idx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>srcstr_len</span> <span class=o>=</span> <span class=n>src_string</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>entry_stop_str_len</span> <span class=o>=</span> <span class=n>entry_stop_str</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// count string lengths in the left_to_right map keys
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=o>&gt;</span> <span class=n>ignore_left_lens</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>itr</span> <span class=p>:</span> <span class=n>ignore_left_to_right_map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>ignore_left_lens</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>itr</span><span class=p>.</span><span class=n>first</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// count string lengths in the left_to_right map keys
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=o>&gt;</span> <span class=n>include_left_lens</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>itr</span> <span class=p>:</span> <span class=n>include_left_to_right_map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>include_left_lens</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>itr</span><span class=p>.</span><span class=n>first</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// itrate through src_string to find all entry strings
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>entry_strs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(</span><span class=n>fast_idx</span> <span class=o>&lt;</span> <span class=n>srcstr_len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// check string between &#34;left&#34; and &#34;right&#34; to include
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>cur_left_len</span> <span class=p>:</span> <span class=n>include_left_lens</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>fast_idx</span> <span class=o>+</span> <span class=n>cur_left_len</span> <span class=o>&gt;</span> <span class=n>srcstr_len</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_left_str</span> <span class=o>=</span> <span class=n>src_string</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>fast_idx</span><span class=p>,</span> <span class=n>cur_left_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>include_left_to_right_map</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>cur_left_str</span><span class=p>)</span> <span class=o>!=</span> <span class=n>include_left_to_right_map</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_right_str</span> <span class=o>=</span> <span class=n>include_left_to_right_map</span><span class=p>[</span><span class=n>cur_left_str</span><span class=p>];</span>
</span></span><span class=line><span class=cl>				<span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>cur_right_len</span> <span class=o>=</span> <span class=n>cur_right_str</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>				<span class=k>for</span> <span class=p>(</span><span class=n>fast_idx</span> <span class=o>+=</span> <span class=n>cur_left_len</span><span class=p>;</span> <span class=n>fast_idx</span> <span class=o>+</span> <span class=n>cur_right_len</span> <span class=o>&lt;</span> <span class=n>srcstr_len</span><span class=p>;</span> <span class=o>++</span><span class=n>fast_idx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=p>(</span><span class=n>src_string</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>fast_idx</span><span class=p>,</span> <span class=n>cur_right_len</span><span class=p>)</span> <span class=o>==</span> <span class=n>cur_right_str</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=n>fast_idx</span> <span class=o>+=</span> <span class=n>cur_right_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// check string between &#34;left&#34; and &#34;right&#34; to exclude
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>cur_left_len</span> <span class=p>:</span> <span class=n>ignore_left_lens</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>fast_idx</span> <span class=o>+</span> <span class=n>cur_left_len</span> <span class=o>&gt;</span> <span class=n>srcstr_len</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_left_str</span> <span class=o>=</span> <span class=n>src_string</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>fast_idx</span><span class=p>,</span> <span class=n>cur_left_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>ignore_left_to_right_map</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>cur_left_str</span><span class=p>)</span> <span class=o>!=</span> <span class=n>ignore_left_to_right_map</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_right_str</span> <span class=o>=</span> <span class=n>ignore_left_to_right_map</span><span class=p>[</span><span class=n>cur_left_str</span><span class=p>];</span>
</span></span><span class=line><span class=cl>				<span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>cur_right_len</span> <span class=o>=</span> <span class=n>cur_right_str</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>				<span class=k>for</span> <span class=p>(</span><span class=n>fast_idx</span> <span class=o>+=</span> <span class=n>cur_left_len</span><span class=p>;</span> <span class=n>fast_idx</span> <span class=o>+</span> <span class=n>cur_right_len</span> <span class=o>&lt;</span> <span class=n>srcstr_len</span><span class=p>;</span> <span class=o>++</span><span class=n>fast_idx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=p>(</span><span class=n>src_string</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>fast_idx</span><span class=p>,</span> <span class=n>cur_right_len</span><span class=p>)</span> <span class=o>==</span> <span class=n>cur_right_str</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=n>fast_idx</span> <span class=o>+=</span> <span class=n>cur_right_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=n>slow_idx</span> <span class=o>=</span> <span class=n>fast_idx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>fast_idx</span> <span class=o>+</span> <span class=n>entry_stop_str_len</span> <span class=o>&gt;</span> <span class=n>srcstr_len</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span> <span class=c1>// reach the end of src_string
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// found complete entry string
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>src_string</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>fast_idx</span><span class=p>,</span> <span class=n>entry_stop_str_len</span><span class=p>)</span> <span class=o>==</span> <span class=n>entry_stop_str</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>entry_strs</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>src_string</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>slow_idx</span><span class=p>,</span> <span class=n>fast_idx</span> <span class=o>-</span> <span class=n>slow_idx</span><span class=p>));</span>
</span></span><span class=line><span class=cl>			<span class=n>slow_idx</span> <span class=o>=</span> <span class=n>fast_idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=o>++</span><span class=n>fast_idx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>entry_strs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Once we have the entry strings, we&rsquo;ll break them down into type, name, and value fields. Each string for these fields will be cleaned up, removing any extra spaces and newline characters at both ends. Then, we&rsquo;ll check if the hashmap has a key with the specified name, using it to identify the entries. We&rsquo;ll then examine the value of the entry and update it with the corresponding value string if the type matches.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>errflag_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// update generic hash map entries according to configuration text file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>errflag_t</span> <span class=n>update_genhashmap_from_txt</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>GenericEntry</span><span class=o>*&gt;&amp;</span> <span class=n>gen_hashmap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>src_file_path</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>openmode</span> <span class=n>src_file_openmode</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>in</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>type_name_dl</span> <span class=o>=</span> <span class=s>&#34; &#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name_val_dl</span> <span class=o>=</span> <span class=s>&#34;=&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>entry_stop_str</span> <span class=o>=</span> <span class=s>&#34;;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&amp;</span> <span class=n>ignore_left_to_right_map</span> <span class=o>=</span> <span class=p>{{</span><span class=s>&#34;//&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>},</span> <span class=p>{</span><span class=s>&#34;/*&#34;</span><span class=p>,</span> <span class=s>&#34;*/&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&amp;</span> <span class=n>include_left_to_right_map</span> <span class=o>=</span> <span class=p>{{</span><span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;&amp;</span> <span class=n>rm_chars</span> <span class=o>=</span> <span class=p>{</span><span class=sc>&#39; &#39;</span><span class=p>,</span> <span class=sc>&#39;\n&#39;</span><span class=p>,</span> <span class=sc>&#39;\t&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>errflag_t</span> <span class=n>err_flag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>ifstream</span> <span class=n>src_file</span><span class=p>(</span><span class=n>src_file_path</span><span class=p>,</span> <span class=n>src_file_openmode</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>src_file</span><span class=p>.</span><span class=n>is_open</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>src_string</span><span class=p>(</span>
</span></span><span class=line><span class=cl>			<span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>istreambuf_iterator</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=n>src_file</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>istreambuf_iterator</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>entry_strings</span> <span class=o>=</span> <span class=n>helper_extract_entrystr</span><span class=p>(</span>
</span></span><span class=line><span class=cl>			<span class=n>src_string</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=n>entry_stop_str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=n>ignore_left_to_right_map</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=n>include_left_to_right_map</span>
</span></span><span class=line><span class=cl>		<span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>cur_entry_str</span> <span class=p>:</span> <span class=n>entry_strings</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tmp_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>tmp_str_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=c1>//clean up entry string
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>tmp_str</span> <span class=o>=</span> <span class=n>helper_bothside_clean_chars</span><span class=p>(</span>
</span></span><span class=line><span class=cl>				<span class=n>cur_entry_str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=n>rm_chars</span>
</span></span><span class=line><span class=cl>			<span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=c1>// split entry string
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>type_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>value_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>helper_split_entrystr_into_type_name_val</span><span class=p>(</span>
</span></span><span class=line><span class=cl>				<span class=n>tmp_str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=n>type_name_dl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=n>name_val_dl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=o>&amp;</span><span class=n>type_string</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=o>&amp;</span><span class=n>name_string</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=o>&amp;</span><span class=n>value_string</span>
</span></span><span class=line><span class=cl>			<span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=c1>// clean up name string
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>name_string</span> <span class=o>=</span> <span class=n>helper_bothside_clean_chars</span><span class=p>(</span>
</span></span><span class=line><span class=cl>				<span class=n>name_string</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=n>rm_chars</span>
</span></span><span class=line><span class=cl>			<span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=c1>// update entry if name exists
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=p>(</span><span class=n>gen_hashmap</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>name_string</span><span class=p>)</span> <span class=o>!=</span> <span class=n>gen_hashmap</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>type_string</span> <span class=o>=</span> <span class=n>helper_bothside_clean_chars</span><span class=p>(</span>
</span></span><span class=line><span class=cl>					<span class=n>type_string</span><span class=p>,</span>
</span></span><span class=line><span class=cl>					<span class=n>rm_chars</span>
</span></span><span class=line><span class=cl>				<span class=p>);</span>
</span></span><span class=line><span class=cl>				<span class=c1>// update entry if type match
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>hp_typename</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=n>gen_hashmap</span><span class=p>[</span><span class=n>name_string</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>get_typename</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hp_typename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=p>(</span><span class=n>type_string</span> <span class=o>==</span> <span class=n>hp_typename</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=n>value_string</span> <span class=o>=</span> <span class=n>helper_bothside_clean_chars</span><span class=p>(</span>
</span></span><span class=line><span class=cl>						<span class=n>value_string</span><span class=p>,</span>
</span></span><span class=line><span class=cl>						<span class=n>rm_chars</span>
</span></span><span class=line><span class=cl>					<span class=p>);</span>
</span></span><span class=line><span class=cl>					<span class=n>gen_hashmap</span><span class=p>[</span><span class=n>name_string</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>read_val_string</span><span class=p>(</span><span class=n>value_string</span><span class=p>);</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;ERR:</span><span class=se>\t</span><span class=s>Type mismatch! &#34;</span> <span class=o>+</span> <span class=n>type_string</span> <span class=o>+</span> <span class=s>&#34; &lt;--&gt; &#34;</span> <span class=o>+</span> <span class=n>hp_typename</span> <span class=o>+</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;ERR:</span><span class=se>\t</span><span class=s>Name not found! &#34;</span> <span class=o>+</span> <span class=n>name_string</span> <span class=o>+</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=n>err_flag</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;ERR:</span><span class=se>\t</span><span class=s> Unable to open file. File path = &#34;</span> <span class=o>+</span> <span class=n>src_file_path</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>err_flag</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>err_flag</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Since we typically use the same separators and comment notations when writing and reading the configuration file, it makes sense to create a class to store these separators and comment notations for the functions responsible for saving and loading the configuration file.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>errflag_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// class for text IO of generic hash map
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>GenHashMapIOTxt</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>type_name_dl</span> <span class=o>=</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name_val_dl</span> <span class=o>=</span> <span class=s>&#34;=&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>entry_stop_str</span> <span class=o>=</span> <span class=s>&#34;;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>default_message_enclousre</span> <span class=o>=</span> <span class=p>{</span> <span class=s>&#34;/*&#34;</span><span class=p>,</span> <span class=s>&#34;*/&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>ignore_left_to_right_map</span> <span class=o>=</span> <span class=p>{</span> <span class=p>{</span><span class=s>&#34;//&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>},</span> <span class=p>{</span><span class=s>&#34;/*&#34;</span><span class=p>,</span> <span class=s>&#34;*/&#34;</span><span class=p>}</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>include_left_to_right_map</span> <span class=o>=</span> <span class=p>{</span> <span class=p>{</span><span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>}</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span> <span class=n>rm_chars</span> <span class=o>=</span> <span class=p>{</span> <span class=sc>&#39; &#39;</span><span class=p>,</span> <span class=sc>&#39;\n&#39;</span><span class=p>,</span> <span class=sc>&#39;\t&#39;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// save generic hash map to file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>errflag_t</span> <span class=nf>save_to_file</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>GenericEntry</span><span class=o>*&gt;&amp;</span> <span class=n>gen_hashmap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>dst_file_path</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>openmode</span> <span class=n>dst_file_openmode</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>out</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>head_message</span> <span class=o>=</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>save_genhashmap_to_txt</span><span class=p>(</span>
</span></span><span class=line><span class=cl>			<span class=n>gen_hashmap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=n>dst_file_path</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=n>dst_file_openmode</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>type_name_dl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=c1>//this-&gt;name_val_dl,
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=s>&#34; &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>name_val_dl</span> <span class=o>+</span> <span class=s>&#34; &#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>entry_stop_str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>default_message_enclousre</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=n>head_message</span>
</span></span><span class=line><span class=cl>		<span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// load generic hash map 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>errflag_t</span> <span class=nf>update_from_file</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>GenericEntry</span><span class=o>*&gt;&amp;</span> <span class=n>gen_hashmap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>src_file_path</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>openmode</span> <span class=n>src_file_openmode</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>in</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>update_genhashmap_from_txt</span><span class=p>(</span>
</span></span><span class=line><span class=cl>			<span class=n>gen_hashmap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=n>src_file_path</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=n>src_file_openmode</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>type_name_dl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>name_val_dl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>entry_stop_str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>ignore_left_to_right_map</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>include_left_to_right_map</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=k>this</span><span class=o>-&gt;</span><span class=n>rm_chars</span>
</span></span><span class=line><span class=cl>		<span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=unit-test>Unit Test<a hidden class=anchor aria-hidden=true href=#unit-test>#</a></h2><p>Finally, we can quickly test the configuration file parser. In the following code, I&rsquo;ve used an integer entry, a vector of floats entry, and a string entry as examples.</p><p>First, we create the generic hashmap and add initial entries to it. Then, we save the generic hashmap to a text file. Next, we modify the values in the generic map. Finally, we load the values from the configuration file.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>GenHashMap</span> <span class=n>test_genhashmap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>GenHashMapIOTxt</span> <span class=n>test_io_txt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// initialize generic hash map
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;int_val&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>IntEntry</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;string_val&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>StringEntry</span><span class=p>(</span><span class=s>&#34;Welcome to Vision Tech Insights!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;vector_float_val&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>VectorFloatEntry</span><span class=p>({</span> <span class=mf>0.1</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.3</span><span class=p>,</span> <span class=mf>0.4</span><span class=p>,</span> <span class=mf>0.5</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;====== Initialize gen hashmap ======&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// print all the values in the generic hash map
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;--- genhashmap values START ---&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>key_val_pair</span> <span class=p>:</span> <span class=n>test_genhashmap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_name_str</span> <span class=o>=</span> <span class=n>key_val_pair</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_type_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_val_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>key_val_pair</span><span class=p>.</span><span class=n>second</span><span class=o>-&gt;</span><span class=n>get_typename</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cur_type_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>key_val_pair</span><span class=p>.</span><span class=n>second</span><span class=o>-&gt;</span><span class=n>write_val_string</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cur_val_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>cur_type_str</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>cur_name_str</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>cur_val_str</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;--- genhashmap values END ---&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// save generic hash map into a text file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;====== Save gen hashmap to text file ======&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// save to txt configuration file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>test_io_txt</span><span class=p>.</span><span class=n>save_to_file</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=n>test_genhashmap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;test_config_file.txt&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>out</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;This is the test configuration file for Vision Tech Insights blog.&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// save generic hash map into a text file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;====== Set values in gen hashmap ======&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// try to change some of the values
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>((</span><span class=n>IntEntry</span><span class=o>*</span><span class=p>)</span><span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;int_val&#34;</span><span class=p>])</span><span class=o>-&gt;</span><span class=n>set</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>((</span><span class=n>StringEntry</span><span class=o>*</span><span class=p>)</span><span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;string_val&#34;</span><span class=p>])</span><span class=o>-&gt;</span><span class=n>set</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=s>&#34;Hello world!&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=p>((</span><span class=n>VectorFloatEntry</span><span class=o>*</span><span class=p>)</span><span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;vector_float_val&#34;</span><span class=p>])</span><span class=o>-&gt;</span><span class=n>set</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>{</span><span class=o>-</span><span class=mf>0.1</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.2</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.3</span><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;--- genhashmap values START ---&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>key_val_pair</span> <span class=p>:</span> <span class=n>test_genhashmap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_name_str</span> <span class=o>=</span> <span class=n>key_val_pair</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_type_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_val_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>key_val_pair</span><span class=p>.</span><span class=n>second</span><span class=o>-&gt;</span><span class=n>get_typename</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cur_type_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>key_val_pair</span><span class=p>.</span><span class=n>second</span><span class=o>-&gt;</span><span class=n>write_val_string</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cur_val_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>cur_type_str</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>cur_name_str</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>cur_val_str</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;--- genhashmap values END ---&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// try to get value from genhashmap
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;====== Get values from gen hashmap ======&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>tmp_int</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>((</span><span class=n>IntEntry</span><span class=o>*</span><span class=p>)</span><span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;int_val&#34;</span><span class=p>])</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp_int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>tmp_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>((</span><span class=n>StringEntry</span><span class=o>*</span><span class=p>)</span><span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;string_val&#34;</span><span class=p>])</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp_string</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>tmp_float_vec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>((</span><span class=n>VectorFloatEntry</span><span class=o>*</span><span class=p>)</span><span class=n>test_genhashmap</span><span class=p>[</span><span class=s>&#34;vector_float_val&#34;</span><span class=p>])</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp_float_vec</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;--- get values START ---&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;tmp_int = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>tmp_int</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;tmp_float_vec = {&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i_val</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i_val</span> <span class=o>&lt;</span> <span class=n>tmp_float_vec</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i_val</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>tmp_float_vec</span><span class=p>[</span><span class=n>i_val</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>i_val</span> <span class=o>&lt;</span> <span class=n>tmp_float_vec</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;}&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;tmp_string = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>tmp_string</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;--- get values END ---&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// load generic hash map from the text file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;====== Load gen hashmap from text file ======&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// update values according to txt configuration file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>test_io_txt</span><span class=p>.</span><span class=n>update_from_file</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=n>test_genhashmap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;test_config_file.txt&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>in</span>
</span></span><span class=line><span class=cl>	<span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;--- genhashmap values START ---&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>key_val_pair</span> <span class=p>:</span> <span class=n>test_genhashmap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_name_str</span> <span class=o>=</span> <span class=n>key_val_pair</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_type_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>cur_val_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>key_val_pair</span><span class=p>.</span><span class=n>second</span><span class=o>-&gt;</span><span class=n>get_typename</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cur_type_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>key_val_pair</span><span class=p>.</span><span class=n>second</span><span class=o>-&gt;</span><span class=n>write_val_string</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cur_val_str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>cur_type_str</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>cur_name_str</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>cur_val_str</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;--- genhashmap values END ---&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// release generic entries and clear gen hashmap
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>clear_genhashmap</span><span class=p>(</span><span class=n>test_genhashmap</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The resulting configuration file (&ldquo;test_config_file.txt&rdquo;) looks like this:</p><pre tabindex=0><code>/*This is the test configuration file for Vision Tech Insights blog.*/
int int_val = 1;
string string_val = &#34;Welcome to Vision Tech Insights!&#34;;
vector_float vector_float_val = {0.100000,0.200000,0.300000,0.400000,0.500000};
</code></pre><p>The output of the execution is as follows:</p><pre tabindex=0><code>====== Initialize gen hashmap ======

--- genhashmap values START ---
int int_val = 1
string string_val = &#34;Welcome to Vision Tech Insights!&#34;
vector_float vector_float_val = {0.100000,0.200000,0.300000,0.400000,0.500000}
--- genhashmap values END ---

====== Save gen hashmap to text file ======

====== Set values in gen hashmap ======

--- genhashmap values START ---
int int_val = -1
string string_val = &#34;Hello world!&#34;
vector_float vector_float_val = {-0.100000,-0.200000,-0.300000}
--- genhashmap values END ---

====== Get values from gen hashmap ======

--- get values START ---
tmp_int = -1
tmp_float_vec = {-0.1, -0.2, -0.3}
tmp_string = Hello world!
--- get values END ---

====== Load gen hashmap from text file ======

--- genhashmap values START ---
int int_val = 1
string string_val = &#34;Welcome to Vision Tech Insights!&#34;
vector_float vector_float_val = {0.100000,0.200000,0.300000,0.400000,0.500000}
--- genhashmap values END ---
</code></pre><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This post offers an example implementation of a configuration file parser using C++. We&rsquo;ve developed a generic entry class to handle various data types and convert them into strings. Leveraging inheritance and generics in C++ allows us to reuse code blocks for different data types. Storing entries and their corresponding variable names in a hashmap enables us to manage multiple variables simultaneously. With a classic two-pointer-based string processing algorithm, we can save the hashmap to or load it from the configuration file.</p><h2 id=citation>Citation<a hidden class=anchor aria-hidden=true href=#citation>#</a></h2><p>If you found this article helpful, please cite it as:</p><blockquote><p>Zhong, Jian (Apr 2024). Building a Configuration File Parser with C++. Vision Tech Insights. <a href=https://jianzhongdev.github.io/VisionTechInsights/posts/building_a_configuration_file_parser_with_cpp/>https://jianzhongdev.github.io/VisionTechInsights/posts/building_a_configuration_file_parser_with_cpp/</a>.</p></blockquote><p>Or</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl>@article{zhong2024configfileparsercpp,
</span></span><span class=line><span class=cl>  title   = &#34;Building a Configuration File Parser with C++&#34;,
</span></span><span class=line><span class=cl>  author  = &#34;Zhong, Jian&#34;,
</span></span><span class=line><span class=cl>  journal = &#34;jianzhongdev.github.io&#34;,
</span></span><span class=line><span class=cl>  year    = &#34;2024&#34;,
</span></span><span class=line><span class=cl>  month   = &#34;Apr&#34;,
</span></span><span class=line><span class=cl>  url     = &#34;https://jianzhongdev.github.io/VisionTechInsights/posts/building_a_configuration_file_parser_with_cpp/.&#34;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p>[1] &ldquo;Configuration file.&rdquo; Wikipedia, The Free Encyclopedia. Wikimedia Foundation, Inc. Retrieved April 21, 2024, from <a href=https://en.wikipedia.org/wiki/Configuration_file>https://en.wikipedia.org/wiki/Configuration_file</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/hardware-programming/>Hardware Programming</a></li><li><a href=http://localhost:1313/tags/c++/>C++</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/basic_math_for_two_photon_fluorescence_microscopy/><span class=title>Next »</span><br><span>Basic Math for Two Photon Fluorescence Microscopy</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Configuration File Parser with C++ on x" href="https://x.com/intent/tweet/?text=Building%20a%20Configuration%20File%20Parser%20with%20C%2b%2b&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fbuilding_a_configuration_file_parser_with_cpp%2f&amp;hashtags=hardwareprogramming%2cC%2b%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Configuration File Parser with C++ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fbuilding_a_configuration_file_parser_with_cpp%2f&amp;title=Building%20a%20Configuration%20File%20Parser%20with%20C%2b%2b&amp;summary=Building%20a%20Configuration%20File%20Parser%20with%20C%2b%2b&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fbuilding_a_configuration_file_parser_with_cpp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Configuration File Parser with C++ on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fbuilding_a_configuration_file_parser_with_cpp%2f&title=Building%20a%20Configuration%20File%20Parser%20with%20C%2b%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Configuration File Parser with C++ on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fbuilding_a_configuration_file_parser_with_cpp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Configuration File Parser with C++ on whatsapp" href="https://api.whatsapp.com/send?text=Building%20a%20Configuration%20File%20Parser%20with%20C%2b%2b%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fbuilding_a_configuration_file_parser_with_cpp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Configuration File Parser with C++ on telegram" href="https://telegram.me/share/url?text=Building%20a%20Configuration%20File%20Parser%20with%20C%2b%2b&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fbuilding_a_configuration_file_parser_with_cpp%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Configuration File Parser with C++ on ycombinator" href="https://news.ycombinator.com/submitlink?t=Building%20a%20Configuration%20File%20Parser%20with%20C%2b%2b&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fbuilding_a_configuration_file_parser_with_cpp%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Vision Tech Insights</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>